<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RepSpheres: Elevating Elite Sales Teams with Precision Intelligence</title>
  <link rel="icon" type="image/svg+xml" sizes="192x192" href="animated-orb.svg">
  <style>
    :root {
      --primary: #7B42F6;
      --primary-dark: #5B3CFF;
      --secondary: #00ffc6;
      --dark-bg: #0B0B20;
      --card-bg: rgba(40, 20, 70, 0.55);
      --text-light: #ffffff;
      --text-muted: #b39ddb;
      --gradient-primary: linear-gradient(135deg, #7B42F6 0%, #00ffc6 100%);
      --transition-standard: all 0.3s ease;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      color: var(--text-light);
      background-color: var(--dark-bg);
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    h1, h2, h3, h4, h5, h6 {
      margin-bottom: 1rem;
      line-height: 1.2;
    }
    
    h1 {
      font-size: 3.5rem;
      font-weight: 800;
    }
    
    h2 {
      font-size: 2.5rem;
      font-weight: 700;
    }
    
    h3 {
      font-size: 1.75rem;
      font-weight: 600;
    }
    
    p {
      margin-bottom: 1.5rem;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .section {
      padding: 5rem 0;
      position: relative;
    }
    
    .section-title {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .section-title-underline {
      display: block;
      width: 120px;
      height: 5px;
      background: var(--gradient-primary);
      border-radius: 3px;
      margin: 0.5rem auto 3rem;
      box-shadow: 0 0 18px rgba(138, 79, 255, 0.5);
    }
    
    /* Navbar styles */
    .navbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem 2rem;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      transition: var(--transition-standard);
      backdrop-filter: blur(8px);
      background: rgba(11, 11, 32, 0.8);
    }
    
    .navbar-brand {
      display: flex;
      align-items: center;
      font-size: 1.5rem;
      font-weight: 700;
    }
    
    .nav-links {
      display: flex;
      gap: 2rem;
    }
    
    .nav-link {
      color: var(--text-light);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition-standard);
    }
    
    .nav-link:hover {
      color: var(--secondary);
    }
    
    .cta-button {
      background: var(--gradient-primary);
      border: none;
      color: var(--text-light);
      font-weight: 600;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      cursor: pointer;
      transition: var(--transition-standard);
      text-decoration: none;
      display: inline-block;
      box-shadow: 0 4px 12px rgba(123, 66, 246, 0.3);
    }
    
    .cta-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(123, 66, 246, 0.5);
    }
    
    .navbar-toggle {
      display: none;
      background: none;
      border: none;
      cursor: pointer;
    }
    
    .bar {
      display: block;
      width: 25px;
      height: 3px;
      margin: 5px auto;
      background-color: var(--text-light);
      transition: var(--transition-standard);
    }
    
    /* Starry Background */
    .starry-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background-color: var(--dark-bg);
      overflow: hidden;
      pointer-events: none;
    }
    
    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      opacity: 0;
      animation: twinkle var(--twinkle-duration, 3s) infinite ease-in-out var(--twinkle-delay, 0s);
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.2; transform: scale(0.8); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    /* Hero section */
    .hero {
      min-height: 100vh;
      display: flex;
      align-items: center;
      padding-top: 5rem;
      position: relative;
      overflow: hidden;
      background: transparent;
    }
    
    .hero-content {
      max-width: 600px;
      z-index: 10;
      position: relative;
    }
    
    .hero h1 {
      margin-bottom: 1.5rem;
    }
    
    .gradient-text {
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      display: inline-block;
    }
    
    .hero-evolved {
      font-size: 3rem;
      font-weight: 800;
    }
    
    .hero-subhead {
      font-size: 1.25rem;
      margin-bottom: 2rem;
    }
    
    .hero-cta {
      padding: 1rem 2.5rem;
      font-size: 1.1rem;
    }
    
    /* Animated Orbs */
    #orbSVG {
      width: 100vw;
      height: 100vh;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 2;
      pointer-events: none;
      touch-action: none;
    }
    
    /* Problem section */
    .problem-section {
      background: linear-gradient(135deg, var(--dark-bg) 0%, var(--primary) 100%);
      text-align: center;
    }
    
    .problem-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: center;
      margin-top: 3rem;
    }
    
    .card {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 2rem;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 32px rgba(123, 66, 246, 0.3), 0 0 0 2px rgba(0, 255, 198, 0.2);
      border: 1.5px solid rgba(123, 66, 246, 0.25);
      transition: var(--transition-standard);
      flex: 1 1 300px;
      max-width: 350px;
      min-width: 250px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card:hover {
      transform: translateY(-8px);
      box-shadow: 0 8px 40px rgba(0, 255, 198, 0.3), 0 4px 32px rgba(123, 66, 246, 0.3);
    }
    
    .card-icon {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }
    
    .card-title {
      margin-bottom: 1rem;
      color: var(--text-light);
    }
    
    .card-content {
      color: var(--text-muted);
    }
    
    /* Solution section */
    .solution-section {
      background: radial-gradient(circle at 30% 50%, rgba(0, 255, 198, 0.1), transparent 70%),
                  radial-gradient(circle at 70% 50%, rgba(123, 66, 246, 0.1), transparent 70%);
      text-align: center;
    }
    
    .solution-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: center;
      margin-top: 3rem;
    }
    
    /* Timeline section */
    .timeline-section {
      position: relative;
    }
    
    .timeline {
      position: relative;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem 0;
    }
    
    .timeline::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 4px;
      background: var(--gradient-primary);
      transform: translateX(-50%);
      border-radius: 2px;
    }
    
    .timeline-item {
      position: relative;
      margin-bottom: 4rem;
      width: 100%;
    }
    
    .timeline-item:last-child {
      margin-bottom: 0;
    }
    
    .timeline-content {
      position: relative;
      width: calc(50% - 3rem);
    }
    
    .timeline-item:nth-child(odd) .timeline-content {
      margin-left: auto;
      text-align: left;
    }
    
    .timeline-item:nth-child(even) .timeline-content {
      margin-right: auto;
      text-align: right;
    }
    
    .timeline-marker {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 50px;
      background: var(--gradient-primary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-light);
      box-shadow: 0 0 20px rgba(123, 66, 246, 0.5);
      z-index: 10;
    }
    
    /* Moat section */
    .moat-section {
      background: linear-gradient(120deg, var(--dark-bg) 0%, var(--primary) 100%);
      text-align: center;
    }
    
    .moat-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: center;
      margin-top: 3rem;
    }
    
    /* Deployment section */
    .deployment-section {
      background: radial-gradient(circle at 30% 50%, rgba(0, 255, 198, 0.1), transparent 70%),
                  radial-gradient(circle at 70% 50%, rgba(123, 66, 246, 0.1), transparent 70%);
      text-align: center;
    }
    
    .deployment-timeline {
      display: flex;
      flex-direction: column;
      gap: 2rem;
      max-width: 800px;
      margin: 3rem auto 0;
    }
    
    .deployment-item {
      display: flex;
      align-items: flex-start;
      gap: 1.5rem;
    }
    
    .deployment-marker {
      min-width: 50px;
      height: 50px;
      background: var(--gradient-primary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
      box-shadow: 0 0 20px rgba(123, 66, 246, 0.5);
    }
    
    .deployment-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 2rem;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 32px rgba(123, 66, 246, 0.3), 0 0 0 2px rgba(0, 255, 198, 0.2);
      border: 1.5px solid rgba(123, 66, 246, 0.25);
      flex: 1;
      text-align: left;
    }
    
    .phase-tag {
      display: inline-block;
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }
    
    /* CTA section */
    .cta-section {
      background: var(--gradient-primary);
      border-radius: 30px;
      text-align: center;
      padding: 4rem 2rem;
      max-width: 900px;
      margin: 5rem auto 0;
      box-shadow: 0 4px 32px rgba(123, 66, 246, 0.5);
    }
    
    .cta-title {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
    }
    
    .cta-description {
      font-size: 1.25rem;
      max-width: 600px;
      margin: 0 auto 2rem;
    }
    
    .cta-button-large {
      padding: 1.2rem 3rem;
      font-size: 1.2rem;
      background: var(--dark-bg);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
    }
    
    .cta-button-large:hover {
      background: var(--dark-bg);
      transform: translateY(-5px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }
    
    /* Footer */
    .footer {
      background: var(--dark-bg);
      padding: 4rem 0 2rem;
      text-align: center;
    }
    
    .footer-links {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .footer-link {
      color: var(--text-muted);
      text-decoration: none;
      transition: var(--transition-standard);
    }
    
    .footer-link:hover {
      color: var(--secondary);
    }
    
    .copyright {
      color: var(--text-muted);
      font-size: 0.9rem;
    }
    
    /* Responsive design */
    @media (max-width: 1024px) {
      h1 {
        font-size: 3rem;
      }
      
      h2 {
        font-size: 2.2rem;
      }
      
      .timeline::before {
        left: 60px;
      }
      
      .timeline-content {
        width: calc(100% - 90px);
        margin-left: 90px !important;
        text-align: left !important;
      }
      
      .timeline-marker {
        left: 60px;
      }
    }
    
    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }
      
      h2 {
        font-size: 2rem;
      }
      
      .hero {
        text-align: center;
      }
      
      .hero-content {
        max-width: 100%;
      }
      
      .navbar {
        padding: 1rem;
      }
      
      .nav-links {
        position: fixed;
        top: 70px;
        left: 0;
        right: 0;
        flex-direction: column;
        background: rgba(26, 19, 51, 0.95);
        backdrop-filter: blur(10px);
        padding: 2rem;
        gap: 1.5rem;
        transform: translateY(-150%);
        transition: transform 0.3s ease;
        z-index: 999;
      }
      
      .nav-links.active {
        transform: translateY(0);
      }
      
      .navbar-toggle {
        display: block;
      }
      
      .navbar-toggle.active .bar:nth-child(1) {
        transform: translateY(8px) rotate(45deg);
      }
      
      .navbar-toggle.active .bar:nth-child(2) {
        opacity: 0;
      }
      
      .navbar-toggle.active .bar:nth-child(3) {
        transform: translateY(-8px) rotate(-45deg);
      }
      
      .section {
        padding: 4rem 0;
      }
    }
    
    @media (max-width: 576px) {
      h1 {
        font-size: 2.2rem;
      }
      
      h2 {
        font-size: 1.8rem;
      }
      
      .hero-evolved {
        font-size: 2.2rem;
      }
      
      .hero-subhead {
        font-size: 1.1rem;
      }
      
      .hero-cta {
        padding: 0.8rem 2rem;
      }
      
      .section-title-underline {
        width: 80px;
      }
      
      .timeline::before {
        left: 30px;
      }
      
      .timeline-content {
        width: calc(100% - 60px);
        margin-left: 60px !important;
      }
      
      .timeline-marker {
        left: 30px;
        width: 40px;
        height: 40px;
        font-size: 1.2rem;
      }
      
      .deployment-marker {
        min-width: 40px;
        height: 40px;
        font-size: 1.2rem;
      }
      
      .deployment-content {
        padding: 1.5rem;
      }
      
      .cta-title {
        font-size: 2rem;
      }
      
      .cta-description {
        font-size: 1.1rem;
      }
      
      .cta-button-large {
        padding: 1rem 2.5rem;
        font-size: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="navbar-brand">
      <span>RepSpheres</span>
    </div>
    <div class="nav-links">
      <a href="/blog.html" class="nav-link">Blogs</a>
      <a href="/podcast.html" class="nav-link">Podcasts</a>
      <a href="/dashboard/vault.html" class="nav-link">Intelligence Vault</a>
      <a href="/workspace.html" class="nav-link">Sphere OS</a>
    </div>
    <button class="navbar-toggle" id="navbar-toggle" aria-label="Toggle navigation" aria-expanded="false">
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
    <button id="login-btn" class="cta-button">Sign Up / Login</button>
  </nav>

  <!-- Starry Background -->
  <div class="starry-background" id="starryBackground"></div>

  <!-- Hero Section -->
  <section class="hero section" id="hero">
    <svg id="orbSVG">
      <g id="particles"></g>
      <defs>
        <radialGradient id="parentGrad" cx="50%" cy="50%" r="70%">
          <stop id="p0" offset="0%" stop-color="#00E5FF"/>
          <stop id="p1" offset="100%" stop-color="#5B3CFF"/>
          <stop id="p2" offset="50%" stop-color="#00E5FF"/>
          <stop id="p3" offset="75%" stop-color="#5B3CFF"/>
        </radialGradient>
        <radialGradient id="childGrad0" cx="50%" cy="50%" r="70%">
          <stop id="c0s0" offset="0%" stop-color="#B3D8FF"/>
          <stop id="c0s1" offset="100%" stop-color="#0A192F"/>
        </radialGradient>
        <radialGradient id="childGrad1" cx="50%" cy="50%" r="70%">
          <stop id="c1s0" offset="0%" stop-color="#C6FFD9"/>
          <stop id="c1s1" offset="100%" stop-color="#145A32"/>
        </radialGradient>
        <radialGradient id="childGrad2" cx="50%" cy="50%" r="70%">
          <stop id="c2s0" offset="0%" stop-color="#FFB3C9"/>
          <stop id="c2s1" offset="100%" stop-color="#7B1F3A"/>
        </radialGradient>
        <radialGradient id="childGrad3" cx="50%" cy="50%" r="70%">
          <stop id="c3s0" offset="0%" stop-color="#E0D1FF"/>
          <stop id="c3s1" offset="100%" stop-color="#311B4F"/>
        </radialGradient>
        <radialGradient id="childGrad4" cx="50%" cy="50%" r="70%">
          <stop id="c4s0" offset="0%" stop-color="#FFF5B3"/>
          <stop id="c4s1" offset="100%" stop-color="#4B3800"/>
        </radialGradient>
      </defs>
      <path id="parentOrb" fill="url(#parentGrad)" opacity="0.95"/>
      <g id="children"></g>
    </svg>
    <div class="container">
      <div class="hero-content">
        <h1>
          Sales<br>
          <span class="gradient-text">Intelligence</span><br>
          <span class="hero-evolved">Evolved</span>
        </h1>
        <p class="hero-subhead">
          Give your team the unfair advantage of AI-driven psychology—decode what makes buyers say "yes," eliminate guesswork, and engineer success at every stage of the sales journey.
        </p>
        <a href="#schedule" class="cta-button hero-cta">Start Winning More Deals</a>
      </div>
    </div>
  </section>

  <!-- Problem Section -->
  <section class="problem-section section" id="problem">
    <div class="container">
      <h2 class="section-title">What's Holding Elite Sales Teams Back?</h2>
      <span class="section-title-underline"></span>
      <p class="section-description" style="text-align: center; max-width: 700px; margin: 0 auto 3rem;">
        Even the best sales teams hit a wall—buried under disconnected tools, generic messaging, and missed opportunities. <strong>The real cost?</strong> Lost deals, wasted effort, and burnout.
      </p>
      <div class="problem-cards">
        <div class="card">
          <div class="card-icon">🧩</div>
          <h3 class="card-title">Fragmented Tools</h3>
          <p class="card-content">Juggling too many platforms leads to confusion, wasted time, and critical insights slipping through the cracks.</p>
        </div>
        <div class="card">
          <div class="card-icon">⏳</div>
          <h3 class="card-title">Momentum Killers</h3>
          <p class="card-content">Every context switch and manual step drains energy and slows down the path from insight to closed deal.</p>
        </div>
        <div class="card">
          <div class="card-icon">🗣️</div>
          <h3 class="card-title">One-Size-Fits-None</h3>
          <p class="card-content">Personalization is promised but rarely delivered—most outreach is bland, forgettable, and easy to ignore.</p>
        </div>
      </div>
      <p style="text-align: center; margin-top: 3rem; font-size: 1.2rem;">
        It's time to break through the plateau. <strong>RepSpheres</strong> unifies, personalizes, and accelerates every step.
      </p>
    </div>
  </section>

  <!-- Solution Section -->
  <section class="solution-section section" id="solution">
    <div class="container">
      <h2 class="section-title">Give Your Sales Team an Unfair Advantage</h2>
      <span class="section-title-underline"></span>
      <p class="section-description" style="text-align: center; max-width: 700px; margin: 0 auto 3rem;">
        Give your team the power to move faster, personalize smarter, and close deals others miss—powered by psychological science and AI.
      </p>
      <div class="solution-cards">
        <div class="card">
          <div class="card-icon">⚡</div>
          <h3 class="card-title">Instant Buyer Insights</h3>
          <p class="card-content">Know exactly what motivates each prospect—no guesswork, just results.</p>
        </div>
        <div class="card">
          <div class="card-icon">🤖</div>
          <h3 class="card-title">Personalization at Scale</h3>
          <p class="card-content">Deliver messaging that feels tailor-made, every time, automatically.</p>
        </div>
        <div class="card">
          <div class="card-icon">🚀</div>
          <h3 class="card-title">Seamless Automation</h3>
          <p class="card-content">Connect your tools, automate the busywork, and let your reps focus on selling.</p>
        </div>
      </div>
      <div style="text-align: center; margin-top: 3rem;">
        <a href="#schedule" class="cta-button hero-cta">Start Winning More Deals</a>
      </div>
    </div>
  </section>

  <!-- Spheres Ecosystem Section -->
  <section class="ecosystem-section section" id="ecosystem">
    <div class="container">
      <h3 style="text-align: center; color: var(--secondary); font-size: 1.2rem; margin-bottom: 0.5rem;">Why settle for generic outreach?</h3>
      <h2 class="section-title">Spheres Ecosystem</h2>
      <span class="section-title-underline"></span>
      <p class="section-description" style="text-align: center; max-width: 800px; margin: 0 auto 2rem;">
        RepSpheres connects to <strong style="color: var(--secondary);">leading LLMs (OpenAI, Anthropic, Google Gemini, Mistral, and more)</strong> and proprietary models—plus 100+ APIs—to orchestrate intelligence, outreach, and learning in real time.
      </p>
      <p style="text-align: center; margin-bottom: 3rem;">
        The diagram below visualizes how data and AI connect throughout your workflow.
      </p>
      <div style="text-align: center; margin-bottom: 3rem;">
        <!-- Placeholder for the ecosystem visualization -->
        <svg width="800" height="400" viewBox="0 0 800 400" style="max-width: 100%;">
          <!-- SVG content for ecosystem visualization would go here -->
          <rect width="800" height="400" fill="rgba(26, 19, 51, 0.3)" rx="20" ry="20" stroke="url(#neon-border)" stroke-width="2"/>
          <text x="400" y="200" text-anchor="middle" fill="white" font-size="20">Ecosystem Visualization</text>
        </svg>
      </div>
    </div>
  </section>

  <!-- How It Works Timeline -->
  <section class="timeline-section section" id="timeline">
    <div class="container">
      <h2 class="section-title">How RepSpheres Works</h2>
      <span class="section-title-underline"></span>
      <div class="timeline">
        <div class="timeline-item">
          <div class="timeline-marker">1</div>
          <div class="timeline-content card">
            <h3>Sphere Creation</h3>
            <p>Create a Sphere for any target, account, or opportunity—this becomes your workspace for focused intelligence and engagement.</p>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-marker">2</div>
          <div class="timeline-content card">
            <h3>Data Ingestion & Enrichment</h3>
            <p>Automatically pull in and enrich data from your CRM, web, email, and other connected sources.</p>
          </div>
        </div>
        <div class="timeline-item">
        <div class="timeline-marker">3</div>
          <div class="timeline-content card">
            <h3>Psychological Trigger Mapping</h3>
            <p><strong>RepSpheres</strong> analyzes all available data to identify the psychological motivators and triggers most likely to drive action—leveraging a library of 150+ behavioral science principles.</p>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-marker">4</div>
          <div class="timeline-content card">
            <h3>Automated Playbooks & Messaging</h3>
            <p>Launch automations or receive suggested actions—personalized messaging, outreach, or tasks—algorithmically aligned to each target's unique psychological fingerprint.</p>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-marker">5</div>
          <div class="timeline-content card">
            <h3>Feedback & Optimization</h3>
            <p>Results and engagement data flow back into the Sphere, powering continuous learning and smarter future actions.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Moat Section -->
  <section class="moat-section section" id="exclusivity">
    <div class="container">
      <h2 class="section-title">The Strategic Moat – Exclusive Licensing</h2>
      <span class="section-title-underline"></span>
      <div class="moat-cards">
        <div class="card">
          <div class="card-icon">🔒</div>
          <h3 class="card-title">Limited Distribution</h3>
          <p class="card-content">This system isn't mass distributed. It's reserved for elite teams who understand the power of true exclusivity.</p>
        </div>
        <div class="card">
          <div class="card-icon">🛡️</div>
          <h3 class="card-title">Vertical Protection</h3>
          <p class="card-content">One team per vertical. One license per region. That's how moats are built and competitive advantages are maintained.</p>
        </div>
        <div class="card">
          <div class="card-icon">🧬</div>
          <h3 class="card-title">Proprietary Advantage</h3>
          <p class="card-content">While competitors struggle with generic messaging, your team operates with psychological precision that can't be replicated.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Deployment Timeline -->
  <section class="deployment-section section" id="deployment">
    <div class="container">
      <h2 class="section-title">Deployment Timeline</h2>
      <span class="section-title-underline"></span>
      <div class="deployment-timeline">
        <div class="deployment-item">
          <div class="deployment-marker">1</div>
          <div class="deployment-content">
            <span class="phase-tag">Weeks 1-2</span>
            <h3>Phase 1: Stack Audit & Trigger Mapping</h3>
            <p>We analyze your existing tools and map your ideal customer's psychological triggers.</p>
          </div>
        </div>
        <div class="deployment-item">
          <div class="deployment-marker">2</div>
          <div class="deployment-content">
            <span class="phase-tag">Weeks 3-4</span>
            <h3>Phase 2: Territory Intelligence Sync</h3>
            <p>We connect your data sources and begin enriching leads with psychological insights.</p>
          </div>
        </div>
        <div class="deployment-item">
          <div class="deployment-marker">3</div>
          <div class="deployment-content">
            <span class="phase-tag">Week 5</span>
            <h3>Phase 3: Content Engine Activation</h3>
            <p>Your custom messaging library goes live, with personalized communications ready for deployment.</p>
          </div>
        </div>
        <div class="deployment-item">
          <div class="deployment-marker">4</div>
          <div class="deployment-content">
            <span class="phase-tag">Week 6</span>
            <h3>Phase 4: Sales Coaching & Execution Loop</h3>
            <p>Your team receives training on the system and begins implementing trigger-based communications.</p>
          </div>
        </div>
        <div class="deployment-item">
          <div class="deployment-marker">5</div>
          <div class="deployment-content">
            <span class="phase-tag">Ongoing</span>
            <h3>Phase 5: Continuous Optimization</h3>
            <p>We monitor results, refine triggers, and continuously improve the system's effectiveness.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- CTA Section -->
  <section class="cta-section" id="schedule">
    <h2 class="cta-title">Ready to Transform Your Sales Team?</h2>
    <p class="cta-description">Take the first step toward elite sales performance. Schedule a call with our team to discover how RepSpheres can elevate your results.</p>
    <a href="#contact" class="cta-button cta-button-large">Schedule a Call</a>
  </section>

  <!-- Footer -->
  <footer class="footer section">
    <div class="container">
      <div class="footer-links">
        <a href="/blog.html" class="footer-link">Blog</a>
        <a href="/podcast.html" class="footer-link">Podcast</a>
        <a href="/dashboard/vault.html" class="footer-link">Intelligence Vault</a>
        <a href="/workspace.html" class="footer-link">Sphere OS</a>
        <a href="/privacy.html" class="footer-link">Privacy Policy</a>
        <a href="/terms.html" class="footer-link">Terms of Service</a>
      </div>
      <p class="copyright">© 2025 RepSpheres. All rights reserved.</p>
    </div>
  </footer>

  <!-- JavaScript for interactive elements -->
  <script>
    // Mobile navigation toggle
    const navbarToggle = document.getElementById('navbar-toggle');
    const navLinks = document.querySelector('.nav-links');
    
    navbarToggle.addEventListener('click', () => {
      navbarToggle.classList.toggle('active');
      navLinks.classList.toggle('active');
    });
    
    // Create starry background
    function createStarryBackground() {
      const background = document.getElementById('starryBackground');
      const count = 300;
      
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.classList.add('star');
        
        // Random position
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        
        // Random size between 1px and 3px
        const size = 1 + Math.random() * 2;
        
        // Random twinkle duration and delay
        const duration = 3 + Math.random() * 7;
        const delay = Math.random() * 5;
        
        star.style.left = `${x}%`;
        star.style.top = `${y}%`;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.setProperty('--twinkle-duration', `${duration}s`);
        star.style.setProperty('--twinkle-delay', `${delay}s`);
        
        background.appendChild(star);
      }
    }
    
    // --- Utility functions for orb animation ---
    function lerp(a, b, t) { return a + (b - a) * t; }
    function hslToHex(h, s, l) {
      h /= 360; s /= 100; l /= 100;
      let r, g, b;
      if (s === 0) { r = g = b = l; }
      else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
    }
    function lerpColor(a, b, t) {
      const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
      const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
      const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
      const rr = Math.round(ar + (br - ar) * t);
      const rg = Math.round(ag + (bg - ag) * t);
      const rb = Math.round(ab + (bb - ab) * t);
      return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
    }
    function generateSuperSmoothBlob(cx, cy, r, points, t, amp=1, phase=0) {
      const pts = [];
      for (let i = 0; i < points; i++) {
        const angle = (Math.PI * 2 * i) / points;
        const noise =
          Math.sin(angle * 3 + t * 0.7 + phase) * 4 * amp +
          Math.sin(angle * 5 - t * 1.1 + phase) * 2 * amp +
          Math.sin(angle * 2 + t * 1.7 + phase) * 1.2 * amp;
        const rad = r + noise;
        pts.push({
          x: cx + Math.cos(angle) * rad,
          y: cy + Math.sin(angle) * rad
        });
      }
      let d = "";
      for (let i = 0; i < points; i++) {
        const p0 = pts[(i - 1 + points) % points];
        const p1 = pts[i];
        const p2 = pts[(i + 1) % points];
        const p3 = pts[(i + 2) % points];
        if (i === 0) {
          d += `M${p1.x.toFixed(2)},${p1.y.toFixed(2)}`;
        }
        const c1x = p1.x + (p2.x - p0.x) / 6;
        const c1y = p1.y + (p2.y - p0.y) / 6;
        const c2x = p2.x - (p3.x - p1.x) / 6;
        const c2y = p2.y - (p3.y - p1.y) / 6;
        d += ` C${c1x.toFixed(2)},${c1y.toFixed(2)} ${c2x.toFixed(2)},${c2y.toFixed(2)} ${p2.x.toFixed(2)},${p2.y.toFixed(2)}`;
      }
      d += "Z";
      return d;
    }

    const childCount = 5;
    // --- Dynamic Color Families ---
    function getDynamicColorFamily(i, now) {
      // Each orb gets a unique base hue, animated over time
      const baseHue = (i * 67 + now * 0.018) % 360;
      const hue2 = (baseHue + 40 + 20 * Math.sin(now * 0.0007 + i)) % 360;
      const sat = 80 + 10 * Math.sin(now * 0.0005 + i);
      const light1 = 60 + 10 * Math.cos(now * 0.0004 + i * 2);
      const light2 = 35 + 15 * Math.sin(now * 0.0006 + i * 3);
      return [hslToHex(baseHue, sat, light1), hslToHex(hue2, sat, light2)];
    }
    
    // parentCenter will be set dynamically below
    const parentRadius = 100;
    const childRadius = 36;
    const childPoints = 48;
    const childAmp = 0.5;
    const childGradIds = [
      "childGrad0", "childGrad1", "childGrad2", "childGrad3", "childGrad4"
    ];
    
    // --- Dynamically resize SVG to fit all orbs ---
    function adjustSVGSize() {
      // Use viewport size for SVG
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // Store for later
      window.viewportSize = {vw, vh};
      // Orbit radii: parentRadius + 120 + i*40 (i = 0..childCount-1)
      const maxChildIndex = childCount - 1;
      const maxOrbit = parentRadius + 120 + maxChildIndex * 40;
      const maxReach = maxOrbit + childRadius + 8; // +8 for morphing amplitude margin
      // Fit orbs within the smallest viewport dimension
      const minDim = Math.min(vw, vh);
      const scale = minDim / (maxReach * 2);
      const size = maxReach * 2 * scale;
      const svg = document.getElementById('orbSVG');
      svg.setAttribute('width', vw);
      svg.setAttribute('height', vh);
      svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
      // Update parentCenter so it's always in the middle
      window.parentCenterBase = window.parentCenter = {x: vw/2, y: vh/2};
      window.orbScale = scale;
    }
    
    const childrenGroup = document.getElementById('children');
    const childOrbs = [];

    // --- Orb State Management ---
    const orbStates = [];
    const parentOrb = document.getElementById('parentOrb');

    // Helper to create default orb state
    function makeOrbState() {
      return {
        drag: 0, // vertical drag offset (from scroll)
        dragTarget: 0, // target drag value
        dragV: 0, // velocity for wobble
        squash: 0, // squash from click
        squashTarget: 0,
        squashV: 0,
        mouseDir: 0, // directionality for mouseover (radians)
        mouseDirTarget: 0,
        mouseDirV: 0,
        wobble: 0, // phase for recovery wobble
        lastUpdate: performance.now(),
      };
    }
    
    // --- Orb Morph Personalities ---
    const orbMorphDirections = [];
    const orbMorphSpeeds = [];
    // Parent orb: slowest, morphs mostly vertical
    orbMorphDirections.push(Math.PI / 2); // 90deg (vertical)
    orbMorphSpeeds.push(0.012);
    // Children: varied directions and speeds
    for (let i = 0; i < childCount; i++) {
      // Angle: spread from vertical to diagonal, with some randomness
      const angle = Math.PI / 2 + (i - (childCount - 1) / 2) * (Math.PI / 8) + (Math.random() - 0.5) * (Math.PI / 12);
      orbMorphDirections.push(angle);
      // Speed: slower for inner, slightly faster for outer (but all slow)
      orbMorphSpeeds.push(0.014 + i * 0.004 + Math.random() * 0.003);
    }
    
    // Parent orb state
    orbStates.push(makeOrbState());
    // Children orb states
    for (let i = 0; i < childCount; i++) {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("fill", `url(#${childGradIds[i]})`);
      path.setAttribute("opacity", "0.95");
      childrenGroup.appendChild(path);
      childOrbs.push(path);
      orbStates.push(makeOrbState());
    }

    // --- Scroll/Drag Gravity Effect ---
    let lastWheelTime = 0;
    window.addEventListener('wheel', (e) => {
      // e.deltaY: positive for down, negative for up
      const now = performance.now();
      const dt = Math.max(1, now - lastWheelTime);
      lastWheelTime = now;
      // Velocity: stronger for faster scrolls, but overall effect is much softer
      const velocity = Math.max(-80, Math.min(80, e.deltaY / dt * 120));
      // Set dragTarget for all orbs, each along its own morph direction
      orbStates.forEach((state, i) => {
        // Project drag along this orb's unique direction
        const angle = orbMorphDirections[i];
        state.dragTarget += Math.sin(angle) * velocity * 1.8 + Math.cos(angle) * velocity * 0.7;
      });
    });

    // --- Animation Interpolation Helpers ---
    function approach(current, target, speed) {
      return current + (target - current) * speed;
    }
    function dampedSpring(current, target, velocity, stiffness, damping) {
      // Simple spring physics for wobble
      const force = (target - current) * stiffness;
      velocity += force;
      velocity *= damping;
      current += velocity;
      return [current, velocity];
    }
    
    // --- Cosmic particle system ---
    let particles = [];

    function animateParticles() {
      // Update and render particles
      particles = particles.filter(p => p.life > 0);
      const particlesGroup = document.getElementById('particles');
      particlesGroup.innerHTML = '';
      for (const p of particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life -= p.decay;
        p.opacity = Math.max(0, p.life);
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", p.x);
        circ.setAttribute("cy", p.y);
        circ.setAttribute("r", p.r * p.opacity);
        circ.setAttribute("fill", p.color);
        circ.setAttribute("opacity", p.opacity * 0.7);
        particlesGroup.appendChild(circ);
      }
    }

    function emitParticles(x, y, color, count = 3, i = 0, now = 0) {
      for (let j = 0; j < count; j++) {
        // Add a sparkle: random hue offset
        let h = (i * 67 + now * 0.018) % 360 + (Math.random() - 0.5) * 24; // sparkle
        let s = 85 + Math.random() * 10;
        let l = 55 + Math.random() * 20;
        const particleColor = hslToHex(h, s, l);
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.4 + Math.random() * 0.7; // slower
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        particles.push({
          x, y,
          vx, vy,
          r: 1.1 + Math.random() * 1.2, // much smaller
          life: 0.6, // fades faster
          decay: 0.025 + Math.random() * 0.015, // fades faster
          color: particleColor,
          opacity: 0.45 // more subtle
        });
      }
    }
    
    function animate() {
      // Animate parent gradient (fluid, spectrum, multi-stop)
      const parentStops = [
        { id: "p0", phase: 0 },
        { id: "p1", phase: Math.PI * 0.5 },
        { id: "p2", phase: Math.PI },
        { id: "p3", phase: Math.PI * 1.5 }
      ];
      const now = performance.now();
      const baseHue = (now * 0.01) % 360;
      for (let i = 0; i < parentStops.length; i++) {
        // Each stop cycles hue with a phase offset for a symphony effect
        const stop = parentStops[i];
        const hue = (baseHue + 60 * Math.sin(now * 0.00015 + stop.phase)) % 360;
        const sat = 80 + 10 * Math.sin(now * 0.0002 + stop.phase);
        const light = 60 + 10 * Math.cos(now * 0.00018 + stop.phase);
        document.getElementById(stop.id).setAttribute("stop-color", hslToHex(hue, sat, light));
      }

      // --- Animate orb morph states (drag gravity, squash, mouseDir, wobble) ---
      for (let i = 0; i < orbStates.length; i++) {
        const state = orbStates[i];
        // Each orb has a unique springiness and damping (slower for parent, varied for children)
        const spring = 0.045 * (1 + orbMorphSpeeds[i]); // lower = slower
        const damping = 0.90 - orbMorphSpeeds[i] * 0.33; // higher = longer wobble
        [state.drag, state.dragV] = dampedSpring(state.drag, state.dragTarget, state.dragV, spring, damping);
        // Wobble on release (slower phase for more dissolution)
        if (Math.abs(state.dragTarget) < 0.1 && Math.abs(state.drag) > 0.1) {
          state.wobble += 0.04 + orbMorphSpeeds[i] * 0.9; // slower, unique for each orb
          state.drag += Math.sin(state.wobble) * Math.max(0, Math.abs(state.drag) * 0.13 * (1 + orbMorphSpeeds[i]));
        } else if (Math.abs(state.dragTarget) < 0.1) {
          state.wobble = 0; // reset when at rest
        }
        // Decay dragTarget very slowly for beautiful dissolution
        state.dragTarget = approach(state.dragTarget, 0, 0.018 + orbMorphSpeeds[i] * 0.6);
      }

      // --- Parent orb ---
      const parentState = orbStates[0];
      const parentMorphT = now * 0.0004;
      const parentDrag = parentState.drag;
      // Morph: drag stretches along its direction, so project drag
      const parentAngle = orbMorphDirections[0];
      const parentDx = Math.cos(parentAngle) * parentDrag;
      const parentDy = Math.sin(parentAngle) * parentDrag;
      const scale = window.orbScale || 1;

      // --- Animate parent orb's position with slow, organic drift ---
      const {vw, vh} = window.viewportSize || {vw: 800, vh: 800};
      // Safe zone: parent can drift within 20% of screen center
      const px = window.parentCenterBase.x + Math.sin(now * 0.00011) * vw * 0.09 + Math.cos(now * 0.00007) * vw * 0.07;
      const py = window.parentCenterBase.y + Math.cos(now * 0.00009) * vh * 0.08 + Math.sin(now * 0.00016) * vh * 0.06;
      window.parentCenter = {x: px, y: py};

      const parentR = (parentRadius + parentDrag * 0.15) * scale;
      const parentAmp = (1 + Math.abs(parentDrag) * 0.008) * scale;
      const parentPath = generateSuperSmoothBlob(px + parentDx * scale, py + parentDy * scale, parentR, 64, parentMorphT, parentAmp);
      parentOrb.setAttribute('d', parentPath);

      // --- Children ---
      // --- Render children orbs in correct z-order ---
      let behind = [], front = [];
      const parentY = window.parentCenter.y;
      childrenGroup.innerHTML = '';
      for (let i = 0; i < childCount; i++) {
        const state = orbStates[i + 1];
        // Animate dynamic color family for each orb
        const fam = getDynamicColorFamily(i, now);
        const tcol = 0.5 + 0.5 * Math.sin(now * 0.0005 + i);
        document.getElementById(`c${i}s0`).setAttribute("stop-color", lerpColor(fam[0], fam[1], tcol));
        document.getElementById(`c${i}s1`).setAttribute("stop-color", lerpColor(fam[1], fam[0], tcol));

        // --- Animate dynamic, space-filling child orbits ---
        // Each child has its own orbit phase, amplitude, and eccentricity
        const baseAngle = (now * 0.00022 + i * (2 * Math.PI / childCount));
        // Orbit radius breathes and wobbles independently
        const {vw, vh} = window.viewportSize || {vw: 800, vh: 800};
        const parentR = (parentRadius + state.drag * 0.15) * (window.orbScale || 1);
        // Max allowed: from edge of parent to edge of screen
        const minEdge = Math.min(
          window.parentCenter.x,
          vw - window.parentCenter.x,
          window.parentCenter.y,
          vh - window.parentCenter.y
        );
        const maxChildOrbit = Math.max(40, minEdge - parentR - childRadius * (window.orbScale || 1) - 16);
        // Animate orbit radius: base + unique slow sine + unique noise
        const orbitPhase = now * (0.00012 + 0.00007 * i) + i * 1.13;
        const orbitWobble = Math.sin(orbitPhase) * 0.18 + Math.cos(orbitPhase * 0.7) * 0.09;
        const minOrbit = parentR + childRadius * (window.orbScale || 1) + 12;
        let rawOrbit = (parentR + 60 + (i * 0.71 + 1.4) * maxChildOrbit / childCount) * (0.7 + 0.23 * orbitWobble);
        const orbitRadius = Math.max(rawOrbit, minOrbit);
        const ellipseA = orbitRadius * 1.3 * (0.97 + 0.07 * Math.sin(now * 0.00013 + i));
        const ellipseB = orbitRadius * 1.1 * (0.97 + 0.07 * Math.cos(now * 0.00016 + i * 2));
        const angle = baseAngle + Math.sin(now * 0.00009 + i * 1.7) * 0.22;
        const dragAngle = orbMorphDirections[i + 1];
        const dx = Math.cos(dragAngle) * state.drag;
        const dy = Math.sin(dragAngle) * state.drag;
        const x = window.parentCenter.x + Math.cos(angle) * ellipseA + dx;
        const y = window.parentCenter.y + Math.sin(angle) * ellipseB + dy;
        const scale = window.orbScale || 1;
        const cR = (childRadius + state.drag * 0.08) * scale;
        const cAmp = (childAmp + Math.abs(state.drag) * 0.006) * scale;
        const morphT = now * 0.0005 + i * 10;
        const childPath = generateSuperSmoothBlob(x * scale + (1 - scale) * window.parentCenter.x, y * scale + (1 - scale) * window.parentCenter.y, cR, childPoints, morphT, cAmp, i);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", childPath);
        path.setAttribute("fill", `url(#${childGradIds[i]})`);
        // Fade out as dragTarget increases, but trigger instant dissolve/appear
        const fadeStart = 40, fadeEnd = 340;
        const fade = Math.min(1, Math.max(0, (fadeEnd - Math.abs(state.dragTarget)) / (fadeEnd - fadeStart)));
        // Track last visible state
        if (state.wasVisible === undefined) state.wasVisible = fade > 0.5;
        // Start dissolving into particles as soon as fade < 0.5
        if (fade < 0.5 && fade > 0.05) {
          const color = lerpColor(fam[0], fam[1], tcol);
          // Emit more particles as fade approaches zero
          const emission = Math.ceil((0.5 - fade) * 12); // up to 6 particles per frame
          emitParticles(x, y, color, emission, i, now);
          path.setAttribute("opacity", fade * 0.95);
        }
        // If orb just became invisible, emit a final burst and hide
        else if (state.wasVisible && fade <= 0.05) {
          const color = lerpColor(fam[0], fam[1], tcol);
          emitParticles(x, y, color, 12, i, now); // big burst
          path.setAttribute("opacity", 0);
          state.wasVisible = false;
        }
        // If orb just became visible, emit appear particles and show
        else if (!state.wasVisible && fade > 0.05) {
          const color = lerpColor(fam[0], fam[1], tcol);
          emitParticles(x, y, color, 9, i, now);
          path.setAttribute("opacity", fade * 0.95);
          state.wasVisible = true;
        } else {
          // Normal fade
          path.setAttribute("opacity", fade * 0.95);
        }
        childrenGroup.appendChild(path);
      }
      // Animate and render particles
      animateParticles();
      requestAnimationFrame(animate);
    }
    
    // Initialize the animation
    window.addEventListener('DOMContentLoaded', () => {
      createStarryBackground();
      adjustSadjustSVGSize();
      animate();
    });
    window.addEventListener('resize', adjustSVGSize);
  </script>
</body>
</html>